import{m as w,p as B,q as _,r as v,s as O,v as E,x as j,y as C,z as S,A as T,g as M,B as H,C as R,D as V}from"./cs5QWvoR.js";const U=()=>{const a=w();return{find:(f,c,l)=>a(`/${f}`,{method:"GET",params:c,...l}),findOne:(f,c,l,d)=>{typeof c=="object"&&(l=c,c=void 0);const D=[f,c].filter(Boolean).join("/");return a(D,{method:"GET",params:l,...d})},create:(f,c,l={})=>a(`/${f}`,{method:"POST",body:{data:c},params:l}),update:(f,c,l,d={})=>{typeof c=="object"&&(l=c,c=void 0);const D=[f,c].filter(Boolean).join("/");return a(D,{method:"PUT",body:{data:l},params:d})},delete:(f,c)=>{const l=[f,c].filter(Boolean).join("/");return a(l,{method:"DELETE"})}}},z=a=>a==="defer"||a===!1;function $(...a){var b;const n=typeof a[a.length-1]=="string"?a.pop():void 0;typeof a[0]!="string"&&a.unshift(n);let[r,h,e={}]=a;if(typeof r!="string")throw new TypeError("[nuxt] [asyncData] key must be a string.");if(typeof h!="function")throw new TypeError("[nuxt] [asyncData] handler must be a function.");const t=B(),f=h,c=()=>_.value,l=()=>t.isHydrating?t.payload.data[r]:t.static.data[r];e.server??(e.server=!0),e.default??(e.default=c),e.getCachedData??(e.getCachedData=l),e.lazy??(e.lazy=!1),e.immediate??(e.immediate=!0),e.deep??(e.deep=_.deep),e.dedupe??(e.dedupe="cancel");const d=e.getCachedData(r,t),D=d!=null;if(!t._asyncData[r]||!e.immediate){(b=t.payload._errors)[r]??(b[r]=_.errorValue);const o=e.deep?v:O;t._asyncData[r]={data:o(D?d:e.default()),pending:v(!D),error:E(t.payload._errors,r),status:v("idle"),_default:e.default}}const s={...t._asyncData[r]};delete s._default,s.refresh=s.execute=(o={})=>{if(t._asyncDataPromises[r]){if(z(o.dedupe??e.dedupe))return t._asyncDataPromises[r];t._asyncDataPromises[r].cancelled=!0}if(o._initial||t.isHydrating&&o._initial!==!1){const u=o._initial?d:e.getCachedData(r,t);if(u!=null)return Promise.resolve(u)}s.pending.value=!0,s.status.value="pending";const y=new Promise((u,i)=>{try{u(f(t))}catch(m){i(m)}}).then(async u=>{if(y.cancelled)return t._asyncDataPromises[r];let i=u;e.transform&&(i=await e.transform(u)),e.pick&&(i=K(i,e.pick)),t.payload.data[r]=i,s.data.value=i,s.error.value=_.errorValue,s.status.value="success"}).catch(u=>{if(y.cancelled)return t._asyncDataPromises[r];s.error.value=T(u),s.data.value=M(e.default()),s.status.value="error"}).finally(()=>{y.cancelled||(s.pending.value=!1,delete t._asyncDataPromises[r])});return t._asyncDataPromises[r]=y,t._asyncDataPromises[r]},s.clear=()=>G(t,r);const g=()=>s.refresh({_initial:!0}),p=e.server!==!1&&t.payload.serverRendered;{const o=H();if(o&&p&&e.immediate&&!o.sp&&(o.sp=[]),o&&!o._nuxtOnBeforeMountCbs){o._nuxtOnBeforeMountCbs=[];const i=o._nuxtOnBeforeMountCbs;R(()=>{i.forEach(m=>{m()}),i.splice(0,i.length)}),V(()=>i.splice(0,i.length))}p&&t.isHydrating&&(s.error.value||d!=null)?(s.pending.value=!1,s.status.value=s.error.value?"error":"success"):o&&(t.payload.serverRendered&&t.isHydrating||e.lazy)&&e.immediate?o._nuxtOnBeforeMountCbs.push(g):e.immediate&&g();const y=S();if(e.watch){const i=j(e.watch,()=>s.refresh());y&&C(i)}const u=t.hook("app:data:refresh",async i=>{(!i||i.includes(r))&&await s.refresh()});y&&C(u)}const P=Promise.resolve(t._asyncDataPromises[r]).then(()=>s);return Object.assign(P,s),P}function G(a,n){n in a.payload.data&&(a.payload.data[n]=void 0),n in a.payload._errors&&(a.payload._errors[n]=_.errorValue),a._asyncData[n]&&(a._asyncData[n].data.value=void 0,a._asyncData[n].error.value=_.errorValue,a._asyncData[n].pending.value=!1,a._asyncData[n].status.value="idle"),n in a._asyncDataPromises&&(a._asyncDataPromises[n]&&(a._asyncDataPromises[n].cancelled=!0),a._asyncDataPromises[n]=void 0)}function K(a,n){const r={};for(const h of n)r[h]=a[h];return r}export{$ as a,U as u};
